#!/usr/bin/python3

""" An UNIX daemon to run the server

"""

import os
import pwd
import sys

import signal
import argparse
import configparser

import pyfortunes

def die(message):
    """ Exit the daemon with an error message

    """
    if not message.endswith("\n"):
        message += "\n"
    sys.stderr.write(message)
    sys.exit(1)


def kill(pid_file):
    """ Kill the process using the pid from the
    given file

    """
    if not os.path.exists(pid_file):
        die("Could not kill pyfd. %s does not exist" % pid_file)
    with open(pid_file, "r") as fp:
        pid_str = fp.read().strip()
    try:
        pid = int(pid_str)
        os.kill(pid, signal.SIGTERM)
    except Exception as e:
        die("Could not kill pyfd. Error was:", e)
    try:
        os.remove(pid_file)
    except Exception as e:
        die("Could not remove pid file. Error was:", e)


def change_process_user(user_name):
    """ Change process user

    """
    pwd_struct = None
    try:
        pwd_struct = pwd.getpwnam(user_name)
    except ValueError:
        die("'%s': no such user" % user_name)
    uid = pwd_struct.pw_uid
    gid = pwd_struct.pw_gid
    try:
        os.setgid(gid)
        os.setuid(uid)
    except Exception as e:
        die("Unable to change user. Error was: %s" % e)


def detach_process():
    """ Detach the process context from parent and session.

    Detach from the parent process and session group, allowing the
    parent to exit while this process continues running.

    Reference: “Advanced Programming in the Unix Environment”,
    section 13.3, by W. Richard Stevens, published 1993 by
    Addison-Wesley.

    """
    def fork_then_exit_parent(error_message):
        """ Fork a child process, then exit the parent process.

        """
        try:
            pid = os.fork()
            if pid > 0:
                os._exit(0)
        except OSError as e:
            die("%s: %s" % (error_message, e))

    fork_then_exit_parent(error_message="Failed first fork")
    os.setsid()
    fork_then_exit_parent(error_message="Failed second fork")

def check_pid_file(pid_file):
    """ Make sure pid file does not exist

    """
    if os.path.exists(pid_file):
        mess = """Could  not start deamon.
%s already exists.
If you are usre pyfd is not running, please \
remove this file and try again""" % pid_file
        die(mess)


def write_pid_file(pid_file):
    """ Write pid to the file

    """
    open_flags = (os.O_CREAT | os.O_EXCL | os.O_WRONLY)
    # rw-r--r--
    open_mode = (
        ((os.R_OK | os.W_OK) << 6) |
        ((os.R_OK) << 3) |
        ((os.R_OK)))
    fd = os.open(pid_file, open_flags, open_mode)
    fp = os.fdopen(fd, 'w')
    pid = os.getpid()
    line = "%d\n" % pid
    fp.write(line)
    fp.close()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("config_file")
    parser.add_argument("--no-daemon", dest='daemon', action='store_false',
        help='Do not detach from console')
    parser.add_argument("--daemon", dest='daemon', action='store_true',
        help='Run as a deamon (this is the default)')
    parser.add_argument("--kill", action='store_true',
        help='Kill a running instance of pyfd daemon')
    parser.set_defaults(daemon=True)

    args = parser.parse_args()
    config_file = args.config_file

    if not os.path.exists(config_file):
        die("Config file: %s does not exist" % config_file)

    config = configparser.ConfigParser()
    config.read(config_file)
    if not 'pyfd' in config:
        die("No [pyfd] section in config file")

    pyfd_conf = config['pyfd']
    port = pyfd_conf.get('port', '8080')
    user = pyfd_conf.get('user', 'pyfd')
    directory = pyfd_conf.get('directory', "/var/lib/pyfd")
    pid_file  = pyfd_conf.get('pid_file',  "/var/run/pyfd.pid")

    port = int(port)

    if not os.path.isdir(directory):
        die("'%s': not a directory" % directory)

    if args.kill:
        kill(pid_file)
        return

    if args.daemon:
        # - Must be root to write in /var/run
        # - Must write the pid *after* the process is detached (otherwise
        #   we would write the wrong pid)
        # - Must check the pid file *before* the process is detached
        #   so that retcode is right
        # - Must write the pid *before* changing user, because
        #   /var/run is only writeable by root
        check_pid_file(pid_file)
        detach_process()
        write_pid_file(pid_file)
        change_process_user(user)
    pyfortunes.server.run_server(directory, port)


if __name__ == "__main__":
    main()
